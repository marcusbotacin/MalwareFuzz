# Randomizing syscall outputs
# Marcus Botacin - UFPR - 2021
# Based on Qiling's examples

import sys                              # receive argv
from qiling import *                    # qiling itself
from qiling.const import QL_VERBOSE     # qiling defs (why am i repeating it?)
from qiling.const import *              # qiling defs
import random                           # randomizing stuff

global log  # I'm too lazy to structure it in a class

# Hooking the stat syscall
def hook_stat(ql, path, struct, *args, **kw):
    # i'm interested in malware checking the resolv file (DNS changer)
    if "/etc/resolv.conf" in ql.mem.string(path):
        # randomize if this call will succeed or fail
        if random.randrange(0,10) >=5:
            # in this case, it succeded (log it!)
            log.write("malicious:resolv.conf:taken\n")
        else:
            # in this case, it should fail
            log.write("malicious:resolv.conf:nottaken\n")
            # then modify eax to return an error code
            # not the best way to do it, but the fastest to prototype
            ql.reg.write("EAX", 0xFF)
    # if not affecting resolv, return as usual

# Hooking the openat syscall
def hook_openat(ql, pos, path, flags, *args, **kw):
    # interested in the host file
    # same as previously
    if "/etc/hosts" in ql.mem.string(path):
        if random.randrange(0,10) >=5:
            log.write("malicious:hosts:taken\n")
        else:
            log.write("malicious:hosts:nottaken\n")
            ql.reg.write("EAX", 0xFF)
    # interested in the /proc subsystem
    if "/proc/" in ql.mem.string(path):
        if random.randrange(0,10) >=5:
            log.write("malicious:proc:taken\n")
        else:
            log.write("malicious:proc:nottaken\n")
            ql.reg.write("EAX", 0xFF)

# Hook ptrace syscall
def hook_ptrace(ql, req, pid, addr, data, *args, **kw):
        # only two options all the time, it succeeds or fail
        if random.randrange(0,10) >=5:
            log.write("malicious:ptrace:taken\n")
        else:
            log.write("malicious:ptrace:nottaken\n")
            ql.reg.write("EAX", 0xFF)

# Hook gethostbyname
def hook_gethostbyname(ql, addr, *args, **kw):
        # Either succeeds or fail
        # side-effect: it calls other syscalls: e.g., socket (be careful if you hook them)
        if random.randrange(0,10) >=5:
            log.write("decision:gethostbyname:taken\n")
        else:
            log.write("decision:gethostbyname:nottaken\n")
            ql.reg.write("EAX", 0x0)

# Hook connect syscall
def hook_connect(ql, sock, addr, len, *args, **kw):
        if random.randrange(0,10) >=5:
            log.write("decision:connect:taken\n")
        else:
            log.write("decision:connect:nottaken\n")
            ql.reg.write("EAX", 0xFF)

# Hook send syscall (sendto variant)
def hook_send(ql, sock, buf, length, flags, *args, **kw):
        if random.randrange(0,10) >=5:
            log.write("decision:send:taken\n")
        else:
            log.write("decision:send:nottaken\n")
            ql.reg.write("EAX", 0xFF)

def hook_sendto(ql, sock, buf, length, flags, addr, addrlen, *args, **kw):
        if random.randrange(0,10) >=5:
            log.write("decision:sendto:taken\n")
        else:
            log.write("decision:sendto:nottaken\n")
            ql.reg.write("EAX", 0xFF)

# Hook recv syscall (recvfrom variant)
def hook_recv(ql, sock, buf, length, flags, *args, **kw):
        if random.randrange(0,10) >=5:
            log.write("decision:recv:taken\n")
        else:
            log.write("decision:recv:nottaken\n")
            ql.reg.write("EAX", 0xFF)

def hook_recvfrom(ql, sock, buf, length, flags, addr, addrlen, *args, **kw):
        if random.randrange(0,10) >=5:
            log.write("decision:recvfrom:taken\n")
        else:
            log.write("decision:recvfrom:nottaken\n")
            ql.reg.write("EAX", 0xFF)

# Hook socketcall
# This is a problematic call because it calls other syscalls
def hook_socketcall(ql, call, arg, *args, **kw):
        if random.randrange(0,10) >=5:
            log.write("decision:socketcall:taken\n")
        else:
            log.write("decision:socketcall:nottaken\n")
            ql.reg.write("EAX", 0xFF)

# This is the executor itselve
def my_sandbox(path, rootfs):
    # setup Qiling engine (extra options if needed)
    ql = Qiling(path, rootfs) #, console=True, verbose=QL_VERBOSE.DEBUG) #, log_dir=".")
    # Hook all desired calls
    # here hooking individually so we can debug them more easily
    ql.set_syscall("stat", hook_stat, QL_INTERCEPT.EXIT)
    ql.set_syscall("openat", hook_openat, QL_INTERCEPT.EXIT)
    ql.set_syscall("ptrace", hook_ptrace, QL_INTERCEPT.EXIT)
    ql.set_syscall("gethostbyname", hook_gethostbyname, QL_INTERCEPT.EXIT)
    ql.set_syscall("connect", hook_connect, QL_INTERCEPT.EXIT)
    ql.set_syscall("send", hook_send, QL_INTERCEPT.EXIT)
    ql.set_syscall("sendto", hook_sendto, QL_INTERCEPT.EXIT)
    ql.set_syscall("recv", hook_recv, QL_INTERCEPT.EXIT)
    ql.set_syscall("recvfrom", hook_recvfrom, QL_INTERCEPT.EXIT)
    ql.set_syscall("socketcall", hook_socketcall, QL_INTERCEPT.EXIT)
    # actually run - with a timeout 10s to test - convert us in s
    ql.run(timeout=10*1000*1000)

# do not import this file (not supported yet)
if __name__ == "__main__":
    # N runs, N distinct paths due to randomization
    for run in range(int(sys.argv[3])):
        # save a log file for each run
        log = open(sys.argv[4]+'/'+str(run),'w')
        log.write("started!\n")
        # run
        try:
            my_sandbox([sys.argv[1]],sys.argv[2])
            log.write("finished!\n")
        # sometimes modifying the syscalls lead to a crash
        except:
            log.write("crashed\n")
