# Ploting execution paths
# Input: traces from a randomized app execution
# Output: execution flow graph
# Marcus Botacin - UFPR - 2021

import networkx as nx               # The Graph
import matplotlib.pyplot as plt     # Plot Lib
import os                           # list dirs
import sys                          # arguments

# We need a graph
# directed because it is a flow
G = nx.DiGraph()
# edges will mean if decision was taken or not
edge_labels = dict()
# for each trace file (representing N runs)
for file in os.listdir(sys.argv[1]):
    # Ugly way to read all lines (assuming small file)
    lines = open(sys.argv[1]+'/'+file).read().strip().split("\n")
    # traversing list looking to (previous,current) nodes
    # Skipping first, expected to be "start"
    for idx in range(1,len(lines)):
        # second item, first edge
        if idx==1:
            v1 = lines[idx-1]               # node label (function)
            v2 = lines[idx].split(":")[1]   # node label (function)
            # always taken, no other option for the first edge
            label = "taken"
        # last item
        elif idx==len(lines)-1:
            v1 = lines[idx-1].split(":")[1]     # node label
            v2 = lines[idx]                     # node label
            label = lines[idx-1].split(":")[2]  # edge label (taken or not)
        # all other cases
        else:
            v1 = lines[idx-1].split(":")[1]         # node label
            v2 = lines[idx].split(":")[1]           # node label
            label = lines[idx-1].split(":")[2]      # edge label
        # create edge based on consecutive nodes
        G.add_edge(v1,v2)
        # store the edge label
        edge_labels[v1,v2] = label

# draw the graph
nx.draw(G, with_labels=True, font_weight='bold')
# try to beautify the layout (i'm not good doing it)
pos = nx.spring_layout(G)
# add the edge labels to the plot
nx.draw_networkx_edge_labels(G,pos,edge_labels=edge_labels,font_color='black')
# finally plot
plt.show() 
